const LEVELS = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60,
};

const LEVEL_LABELS = Object.fromEntries(Object.entries(LEVELS).map(([name, value]) => [value, name]));

function isPlainObject(value) {
  return value !== null && typeof value === 'object' && !Array.isArray(value);
}

function serializeValue(value) {
  if (value instanceof Error) {
    return {
      type: value.name,
      message: value.message,
      stack: value.stack,
    };
  }
  if (Array.isArray(value)) {
    return value.map(serializeValue);
  }
  if (isPlainObject(value)) {
    const output = {};
    for (const [key, val] of Object.entries(value)) {
      output[key] = serializeValue(val);
    }
    return output;
  }
  if (typeof value === 'bigint') {
    return value.toString();
  }
  return value;
}

function createLogger(options = {}, destination) {
  const base = isPlainObject(options.base) ? { ...options.base } : {};
  const timestampFn = options.timestamp === false ? null : options.timestamp || stdTimeFunctions.isoTime;
  const dest = destination && typeof destination.write === 'function' ? destination : process.stdout;

  const emit = (levelName, data, message) => {
    const levelValue = LEVELS[levelName] ?? LEVELS.info;
    const record = { ...base, level: levelValue };
    if (timestampFn) {
      record.time = timestampFn();
    }
    if (message) {
      record.msg = message;
    }
    if (isPlainObject(data)) {
      for (const [key, value] of Object.entries(data)) {
        record[key] = serializeValue(value);
      }
    }
    dest.write(JSON.stringify(record) + '\n');
  };

  const logger = {};

  for (const levelName of Object.keys(LEVELS)) {
    logger[levelName] = (arg1, arg2) => {
      if (typeof arg1 === 'string' || arg1 === undefined) {
        emit(levelName, isPlainObject(arg2) ? arg2 : undefined, arg1 || '');
      } else {
        emit(levelName, arg1, typeof arg2 === 'string' ? arg2 : '');
      }
    };
  }

  logger.child = (bindings = {}) => {
    const childOptions = {
      ...options,
      base: { ...base, ...(isPlainObject(bindings) ? bindings : {}) },
    };
    return createLogger(childOptions, dest);
  };

  logger.level = options.level || 'info';

  return logger;
}

const stdTimeFunctions = {
  isoTime: () => new Date().toISOString(),
};

module.exports = Object.assign(createLogger, {
  stdTimeFunctions,
  levels: {
    values: { ...LEVELS },
    labels: { ...LEVEL_LABELS },
  },
});
